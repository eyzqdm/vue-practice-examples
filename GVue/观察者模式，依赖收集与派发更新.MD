

观察者模式
被观察者身上会绑定多个观察者
当被观察者状态改变 会通知所有的观察者调用自己的更新方法

发布订阅模式就相当于事件中心 它需要一个调度中心（event） 而观察者模式不需要调度中心

vue2中 每个组件对应一个渲染watcher

全局watcher依次让每一个子watcher更新 而子watcher到底更不更新还要看自己的数据变没变？
全局watcher负责更新页面 子watcher负责更新自己？
页面初次渲染时 每个子watcher肯定都会执行一次get方法 来渲染 当执行get时 把该子watcher*挂到全局*？ 来实现依赖收集？
因为不挂到全局的话就没法访问到这个watcher，就无法实现依赖收集。
当get方法执行结束 再把这个watcher踢走 腾出位置给下一个执行get方法的子watcher


依赖收集 每次触发getter时 将被访问的属性绑定到其对应组件的watcher上==》一个watcher可能对应多个属性（因为
一个组件内可能有多个属性） 这样当派发更新时 就知道要更新哪些属性了 没被收集的就不更新
这里的关键应该还是diff diff内部的具体实现

如何将属性绑定到watcher上？
一个属性对应一个dep 他在每个属性被响应化时（defineReactive方法）创建
dep即依赖 getters时被watcher收集起来 setter时同时watcher执行get
一个属性可能有多个wather？
当组件的watcher执行get方法渲染时 组件的每个属性一定会被访问到 即getter一定会被触发。而当getter被触发时，
表示当前watcher的get正在执行，即此时的watcher是全局的！。
那到底如何绑定？
前面说到 被观察者身上会绑定多个观察者，当被观察者状态改变 会通知所有的观察者调用自己的更新方法。

// 这里的dep会绑定多个观察这吗？ 每个组件只会有一个观察者。
而这里的被观察者就是属性，可以看作每个属性对应的那个dep。到这里就全部打通了。
其实dep就相当于那个Subject（小宝宝）对象。他有一个属性用来存储观察者（watcher），有添加和删除观察者的方法。
也有通知观查者执行更新的方法。这就是观察者模式。
因此这里直接把该渲染watcher添加到属性对应的dep的subs中即可
同时 要把该dep存储到watcher 这即是依赖收集。为什么要收集？前面说到，当watcher执行get时，是收集了什么就更新什么。
因此get方法只会更新收集到的dep,而具体更不更新还要看这个属性有没有发生变化，只更新发生变化的dep即局部更新。
这样当页面再次刷新，就只会访问该局部的发生变化的属性，因此也只有这个属性会再次被收集。

watcher和dep是互相引用的关系
依赖收集是watcher收集dep
派发更新是dep通知watcher（可能有多个watcher）更新


因此一个dep可能对象多个watcher 而一个watcher也往往对应多个dep（即组件的多个属性）

问题1 子watcher的get方法的具体实现 全局watcher通知各个子watcher更新？
问题2 收集了什么就更新什么 那么我修改了一个没被收集的属性怎么办？

关键还是diff 两点
1 页面重新渲染时 会不会访问所有的属性 会的话就会被再次依赖收集 
组件重新渲染时 会不会再次访问所有属性？
2 之前的例子 三个属性分别属于三个不同组件？ 依赖收集的是全局watcher？ 
那如果是一个组件的三个属性呢 每次组件更新会不会将三个属性都依赖收集呢？
3 父组件的watcher与子组件的watcher的关系？